============================================================
 LuaFileSystem (lfs) v1.8.0 详细参考文档
============================================================

目录
----
1. 简介
2. 安装
3. API 参考
   - lfs.attributes
   - lfs.symlinkattributes
   - lfs.chdir
   - lfs.currentdir
   - lfs.dir
   - lfs.link
   - lfs.lock
   - lfs.unlock
   - lfs.lock_dir
   - lfs.mkdir
   - lfs.rmdir
   - lfs.setmode
   - lfs.touch
4. 属性表详解
5. 许可证与致谢

------------------------------------------------------------
1. 简介
------------------------------------------------------------

LuaFileSystem (lfs) 是一个为 Lua 编程语言设计的文件系统操作库。它作为 Lua 标准库的补充，提供了一套可移植的、用于访问底层目录结构和文件属性的接口，让开发者能用统一的方式在 Windows、Linux、macOS 等不同操作系统上进行文件系统操作。

其主要特性包括：
- 目录创建、删除与遍历
- 获取和修改文件属性（如大小、修改时间等）
- 创建硬链接和符号链接
- 文件锁定
- 更改和获取当前工作目录

------------------------------------------------------------
2. 安装
------------------------------------------------------------

推荐使用 LuaRocks 包管理器进行安装，这是最简单快捷的方式：

luarocks install luafilesystem

------------------------------------------------------------
3. API 参考
------------------------------------------------------------

在使用 lfs 库前，需要先引入它：
local lfs = require "lfs"

---
### lfs.attributes (filepath [, arg])

获取文件或目录的属性。此函数会跟随符号链接，返回链接指向的目标文件的属性。

-   `filepath` (string): 目标文件或目录的路径。
-   `arg` (string 或 table, 可选):
    -   如果是一个字符串（属性名，如 "size"），则函数仅返回该属性的值。
    -   如果是一个 table，则函数会将所有属性填充到此 table 中并返回它，而不是创建一个新的 table。

返回值:
-   成功: 返回一个包含所有文件属性的 table（或单个属性值）。
-   失败: 返回 `nil`、一个描述错误的字符串、以及一个系统相关的错误码（数字）。

示例:
local attr = lfs.attributes("mydir/myfile.txt")
if attr then
  print("Mode:", attr.mode)
  print("Size:", attr.size)
end

local size = lfs.attributes("mydir/myfile.txt", "size")
print("File size:", size)


---
### lfs.symlinkattributes (filepath [, arg])

功能与 `lfs.attributes` 类似，但用于获取符号链接（symbolic link）本身的属性，而不是它所指向的目标。

-   参数与 `lfs.attributes` 相同。

返回值:
-   成功: 返回一个属性 table。除了 `lfs.attributes` 包含的所有字段外，额外增加一个 `target` 字段，其值为链接指向的目标路径（字符串）。
-   失败: 返回 `nil`、错误信息和错误码。

平台差异:
-   在 Windows 上，此函数当前的行为与 `lfs.attributes` 完全相同，不会返回 `target` 字段。


---
### lfs.chdir (path)

更改当前工作目录。

-   `path` (string): 要切换到的新目录路径。

返回值:
-   成功: 返回 `true`。
-   失败: 返回 `nil` 和一个描述错误的字符串。

示例:
local ok, err = lfs.chdir("/tmp")
if not ok then print("Failed to change dir:", err) end


---
### lfs.currentdir ()

获取当前的工作目录路径。

返回值:
-   成功: 返回一个包含当前目录绝对路径的字符串。
-   失败: 返回 `nil` 和一个描述错误的字符串。


---
### lfs.dir (path)

创建一个用于遍历指定目录中所有条目（文件和子目录）的迭代器。

-   `path` (string): 要遍历的目录路径。

返回值:
-   返回两个值：迭代器函数和目录对象。可用于 `for` 循环。

使用方式:
-   迭代器返回的条目名不包含 `.` 和 `..`。
-   目录对象拥有 `next()` 和 `close()` 方法，可以用于手动迭代和提前关闭目录句柄。在 `for` 循环中，目录句柄会在循环结束或中断时自动关闭。

示例 1 (for 循环):
for entry in lfs.dir("./") do
  print("Found:", entry)
end

示例 2 (手动迭代):
local iter, dir_obj = lfs.dir("./")
while true do
  local entry = dir_obj:next()
  if not entry then break end
  print("Found:", entry)
end
dir_obj:close() -- 手动关闭


---
### lfs.link (old, new [, symlink])

创建一个文件链接。

-   `old` (string): 原始文件路径。
-   `new` (string): 新链接的路径。
-   `symlink` (boolean, 可选): 如果为 `true`，则创建符号链接（软链接）；默认为 `false`，创建硬链接。

返回值:
-   成功: 返回 `true`。
-   失败: 返回 `nil` 和错误信息。

平台差异:
-   Windows 不支持为目录创建硬链接。
-   在 Windows 上创建符号链接可能需要管理员权限。


---
### lfs.lock (filehandle, mode [, start [, length]])

对一个已打开的文件或其一部分进行加锁。

-   `filehandle`: 由 `io.open()` 返回的文件句柄。
-   `mode` (string): 锁定模式。`'r'` 表示读锁（共享锁），`'w'` 表示写锁（排他锁）。
-   `start` (number, 可选): 锁定的起始位置（字节偏移量），默认为 0。
-   `length` (number, 可选): 锁定的长度（字节数）。如果为 0 或省略，则锁定从 `start` 到文件末尾的区域。

返回值:
-   成功: 返回 `true`。
-   失败: 返回 `nil` 和一个描述错误的字符串。


---
### lfs.unlock (filehandle [, start [, length]])

解锁一个已打开的文件或其一部分。参数与 `lfs.lock` 相同。

返回值:
-   成功: 返回 `true`。
-   失败: 返回 `nil` 和一个描述错误的字符串。


---
### lfs.lock_dir (path)

在指定目录中创建一个锁文件 (`lockfile.lfs`)，用于进程或线程间的同步，防止对该目录进行并发操作。

-   `path` (string): 要锁定的目录路径。

返回值:
-   成功: 返回一个锁对象。
-   失败: 返回 `nil` 和错误信息。如果锁已存在，也会失败。

锁对象:
-   该对象有一个 `free()` 方法，调用它可以立即释放锁。
-   当锁对象被 Lua 的垃圾回收器回收时，锁也会被自动释放。

实现机制:
-   Unix-like: 创建一个名为 `lockfile.lfs` 的符号链接。
-   Windows: 创建一个名为 `lockfile.lfs` 的文件，并以特殊方式打开，使其在句柄关闭时自动被系统删除。


---
### lfs.mkdir (dirname)

创建一个新目录。

-   `dirname` (string): 新目录的路径。

返回值:
-   成功: 返回 `true`。
-   失败: 返回 `nil`、错误信息和错误码。


---
### lfs.rmdir (dirname)

删除一个已存在的空目录。

-   `dirname` (string): 要删除的目录路径。

返回值:
-   成功: 返回 `true`。
-   失败: 返回 `nil`、错误信息和错误码。


---
### lfs.setmode (file, mode)

设置已打开文件的读写模式（二进制或文本）。

-   `file`: 由 `io.open()` 返回的文件句柄。
-   `mode` (string): 模式字符串，可以是 `"binary"` 或 `"text"`。

返回值:
-   成功: 返回 `true` 和文件之前的模式字符串。
-   失败: 返回 `nil` 和错误信息。

平台差异:
-   此函数主要影响 Windows 系统，用于控制换行符的转换。
-   在 Unix-like 系统上，二进制和文本模式没有区别，此函数没有实际效果，总是返回之前的模式为 `"binary"`。


---
### lfs.touch (filepath [, atime [, mtime]])

设置文件的访问和修改时间。

-   `filepath` (string): 目标文件路径。
-   `atime` (number, 可选): 访问时间的 Unix 时间戳 (由 `os.time()` 生成)。
-   `mtime` (number, 可选): 修改时间的 Unix 时间戳。

规则:
-   如果 `atime` 和 `mtime` 都省略，则两者都设置为当前时间。
-   如果只提供了 `atime`，则 `mtime` 也被设置为 `atime` 的值。

返回值:
-   成功: 返回 `true`。
-   失败: 返回 `nil`、错误信息和错误码。

------------------------------------------------------------
4. 属性表详解
------------------------------------------------------------

`lfs.attributes` 和 `lfs.symlinkattributes` 返回的 table 中包含以下字段：

-   `mode` (string): 文件类型。可能的值有:
    -   `"file"`: 普通文件
    -   `"directory"`: 目录
    -   `"link"`: 符号链接
    -   `"socket"`: 套接字
    -   `"named pipe"`: 命名管道
    -   `"char device"`: 字符设备
    -   `"block device"`: 块设备
    -   `"other"`: 其他类型

-   `dev` (number): 文件所在的设备 ID。在 Windows 上是驱动器号。
-   `ino` (number): 文件的 inode 编号 (仅 Unix-like 系统)。
-   `nlink` (number): 指向此文件的硬链接数量。
-   `uid` (number): 文件所有者的用户 ID (仅 Unix-like 系统，Windows 上恒为 0)。
-   `gid` (number): 文件所有者的组 ID (仅 Unix-like 系统，Windows 上恒为 0)。
-   `rdev` (number): 特殊文件的设备类型 (仅 Unix-like 系统)。
-   `access` (number): 最后访问时间的 Unix 时间戳。
-   `modification` (number): 最后修改时间的 Unix 时间戳。
-   `change` (number): 文件状态最后改变时间的 Unix 时间戳。
-   `size` (number): 文件大小（以字节为单位）。
-   `permissions` (string): 权限描述字符串，格式类似 "rwxr-xr--" (仅 Unix-like 系统)。
-   `blocks` (number): 文件占用的块数 (仅 Unix-like 系统)。
-   `blksize` (number): 文件系统 I/O 的最佳块大小 (仅 Unix-like 系统)。
-   `target` (string): 符号链接指向的目标路径 (仅由 `lfs.symlinkattributes` 在 Unix-like 系统上返回)。

------------------------------------------------------------
5. 许可证与致谢
------------------------------------------------------------

-   **许可证**: LuaFileSystem 使用 MIT 许可证，与 Lua 5.x 相同。您可以免费将其用于任何目的，只需在您的产品或文档中包含相应的版权声明即可。

-   **致谢**: LuaFileSystem 最初由 Roberto Ierusalimschy, André Carregal 和 Tomás Guisasola 设计和实现。后来由 Fábio Mascarenhas 维护多年，之后由社区的众多贡献者共同维护。