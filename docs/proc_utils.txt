Proc-Utils-FFI 开发者技术参考手册
================================================================================
版本：3.3.5
代号：Refactored / PEShell-Ready
适用环境：Windows / LuaJIT 2.1
依赖库：lua-ffi-bindings (Standard PEShell/ffi Structure)
文档更新日期：2025-11-23
================================================================================

1. 项目概述
--------------------------------------------------------------------------------
Proc-Utils-FFI 是一个专为 Windows 平台设计的、基于 LuaJIT FFI 技术的高性能进程管理库。
它是原 C++ 扩展库的纯 Lua 重构版本，旨在提供无编译依赖的系统级进程控制能力。

主要特性：
- 纯 Lua 实现：零 C 语言编译依赖，直接通过 FFI 调用 Kernel32/Ntdll/Psapi/Wtsapi32。
- 面向对象设计：提供 Process 对象封装，简化句柄管理。
- 资源安全 (RAII)：支持通过 Lua GC 自动回收内核句柄，同时新增显式 close() 方法支持确定性资源释放。
- 深度信息获取：支持跨进程读取命令行 (基于 PEB 解析)、内存使用量、线程数等。
- 提权执行：内置 Session 0 隔离穿透能力，支持以 SYSTEM 权限启动交互式进程。
- Unicode 就绪：全链路采用 WCHAR (UTF-16LE) 处理，完美支持中文路径与参数。

2. 安装与部署
--------------------------------------------------------------------------------
本库依赖于特定的 FFI 绑定库结构（PEShell 标准结构）。

2.1 文件结构要求
确保你的项目目录包含以下结构，以便 require 能够正确加载：

/ (项目根目录)
  |-- proc_utils_ffi.lua  (本库)
  |-- lib/
      |-- ffi/
          |-- Windows/
              |-- sdk/
                  |-- kernel32.lua
                  |-- psapi.lua
                  |-- advapi32.lua
                  |-- wtsapi32.lua
                  |-- userenv.lua
                  |-- ntdll.lua

2.2 引入方式
local proc = require("proc_utils_ffi")

3. API 接口参考
--------------------------------------------------------------------------------
凡是涉及系统调用的 API，返回值均遵循以下统一模式：
- 成功：返回 Process 对象、true 或 具体数据。
- 失败：返回 nil, error_code (number), error_message (string)。

3.1 工厂函数 (创建或打开进程)

proc.exec(command, [working_dir], [show_mode], [desktop_name])
    描述：创建并启动一个新进程。
    参数：
        command (string): 完整的命令行字符串。
        working_dir (string, 可选): 工作目录。
        show_mode (number, 可选): 窗口显示模式，默认 SW_SHOW (5)。
        desktop_name (string, 可选): 指定桌面，例如 "winsta0\default"。
    返回：成功返回 Process 对象，失败返回 nil 及错误信息。

proc.exec_as_system(command, [working_dir], [show_mode])
    描述：模拟 SYSTEM 权限在当前活动用户的会话中启动进程（绕过 Session 0 隔离）。
    场景：通常用于服务程序需要启动用户可见的 GUI 程序时。
    返回：成功返回 Process 对象，失败返回 nil 及错误信息。

proc.open_by_pid(pid, [access])
    描述：通过 PID 打开已存在的进程。
    参数：
        pid (number): 目标进程 ID。
        access (number, 可选): 访问权限，默认为 PROCESS_ALL_ACCESS。
    返回：Process 对象。

proc.open_by_name(exe_name, [access])
    描述：通过可执行文件名（如 "notepad.exe"）打开第一个匹配的进程。
    返回：Process 对象。

proc.current()
    描述：获取当前脚本所在进程的 Process 对象。
    返回：Process 对象。

3.2 静态工具函数 (无需对象即可调用)

proc.exists(pid_or_name)
    描述：检查进程是否存在。
    参数：可以是 PID (number) 或 进程名 (string)。
    返回：如果存在返回其 PID，否则返回 0。

proc.find_all(process_name)
    描述：查找所有匹配该名称的进程 PID。
    返回：PID 数组表 {1024, 2048, ...}。若无匹配返回空表。

proc.terminate_by_pid(pid, [exit_code])
    描述：直接通过 PID 终止进程。
    返回：boolean (成功/失败)。

proc.wait(process_name, [timeout_ms])
    描述：阻塞等待直到指定名称的进程出现。
    参数：timeout_ms 默认为 -1 (无限等待)。
    返回：成功返回 PID，超时返回 nil。

proc.wait_close(pid_or_name, [timeout_ms])
    描述：阻塞等待直到指定进程结束或消失。
    原理：使用 SYNCHRONIZE 权限打开句柄并等待信号，比轮询更高效。
    返回：true 表示进程已结束，false 表示等待超时。

3.3 Process 对象方法
Process 对象持有 Windows 内核句柄。

:close()
    [v3.3.5 新增]
    描述：显式关闭底层句柄并释放资源。
    注意：虽然 Lua GC 会自动关闭句柄，但在高频操作中建议手动调用此方法以避免句柄耗尽。
    返回：boolean。

:is_valid()
    描述：检查当前对象持有的句柄是否有效。
    返回：boolean。

:handle()
    描述：获取原始 FFI 句柄 (cdata<HANDLE>)。
    警告：仅供高级用户使用，请勿手动调用 kernel32.CloseHandle，否则会导致 Double Free。

:terminate([exit_code])
    描述：强制终止该进程。
    参数：exit_code 默认为 0。
    返回：ok, code, msg。

:terminate_tree()
    描述：递归终止该进程及其所有子进程（基于父子进程链）。
    返回：boolean。

:wait_for_exit([timeout_ms])
    描述：等待该进程退出。
    返回：true (已退出), false (超时)。

:get_info()
    描述：获取进程详细快照信息。
    返回：一个包含以下字段的表：
        {
            pid = number,
            parent_pid = number,      -- 父进程 ID
            session_id = number,      -- 会话 ID
            exe_path = string,        -- 可执行文件完整路径
            command_line = string,    -- 完整命令行
            memory_usage_bytes = number, -- 工作集内存占用 (字节)
            thread_count = number     -- 线程数
        }

:get_path()
    描述：仅获取可执行文件路径（高性能版）。
    返回：string。

:get_command_line()
    描述：仅获取命令行参数。
    原理：通过 NtQueryInformationProcess 读取目标进程 PEB。
    返回：string。

:set_priority(priority_char)
    描述：设置进程优先级。
    参数：
        'L': Idle (低)
        'B': Below Normal
        'N': Normal
        'A': Above Normal
        'H': High (高)
        'R': Realtime (实时)
    返回：boolean。

3.4 常量定义 (proc.constants)

SW_HIDE             = 0
SW_SHOWNORMAL       = 1
SW_SHOW             = 5
PROCESS_ALL_ACCESS  = (System Dependent, usually 0x1F0FFF)

4. 技术细节与注意事项
--------------------------------------------------------------------------------

4.1 字符串编码
Windows API 内部使用 UTF-16LE。本库自动处理 Lua String (UTF-8) 与 WCHAR 之间的转换。
- 输入参数自动转为 WCHAR。
- 输出结果自动转为 UTF-8。
- v3.3.5 修复了空字符串指针可能导致的转换崩溃问题。

4.2 资源管理 (RAII)
本库使用 LuaJIT 的 `ffi.gc` 机制绑定句柄。
- 当 Process 对象被垃圾回收时，会自动调用 CloseHandle。
- 推荐在确定不再使用对象时，显式调用 `:close()`，特别是在循环中创建大量进程对象的场景。

4.3 跨进程读取限制
`:get_command_line()` 使用了读取 PEB (Process Environment Block) 的技术。
- 如果目标进程是 64 位而当前脚本运行在 32 位环境（或反之），可能会因为内存布局不同而读取失败。
- 对于受保护的系统进程（如 Antivirus, CSRSS），可能因权限不足 (Access Denied) 而失败。

4.4 错误处理
API 失败时返回的 `error_code` 对应 Windows System Error Codes。
常见代码：
- 5: Access Denied (权限不足，尝试以管理员运行)
- 6: Invalid Handle (句柄无效，可能已关闭)
- 87: Invalid Parameter (参数错误)
- 258: Wait Timeout (等待超时)

5. 变更日志 (v3.3.5)
--------------------------------------------------------------------------------
[FIX] 修复了 ffi.gc 类型错误：Process 对象是 Lua 表而非 userdata，移除了错误的 ffi.gc(self) 调用。
[FIX] 修正了 require 路径，使其符合 PEShell 的 `ffi.Windows.sdk.*` 规范。
[NEW] 新增 `Process:close()` 方法，支持确定性资源释放。
[MOD] 优化 `exec` 和 `exec_as_system`：直接利用创建时返回的句柄，减少一次 OpenProcess 调用。
[MOD] `wait_close` 现在使用 SYNCHRONIZE 权限，降低 CPU 占用。