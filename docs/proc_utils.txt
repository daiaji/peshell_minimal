=====================================================
Proc-Utils: C++ Win32 进程管理工具库 - 技术文档
=====================================================

文件版本: 1.0
文档生成日期: 2025-11-16

目录
-------
1.0 简介
2.0 功能特性
3.0 如何使用
    3.1 C 语言接口使用方法
    3.2 C++ 封装使用方法 (推荐)
4.0 从源码构建
5.0 C 语言 API 参考
    5.1 结构体定义
    5.2 模块 1：进程查找与枚举
    5.3 模块 2：进程创建与执行
    5.4 模块 3：进程信息获取
    5.5 模块 4：进程控制与交互
6.0 C++ 封装 (ProcUtils::Process) API 参考
    6.1 设计理念
    6.2 静态工厂方法
    6.3 成员方法
7.0 许可证


1.0 简介
----------
`proc_utils` 是一个轻量级的、无外部依赖的工具库，为 Windows 平台提供了一套简洁、健壮的 C 语言接口和现代化的 C++ 封装，用于常见的进程管理任务。

该库旨在原子化和简化与进程相关的操作，如查找、创建、终止、等待以及获取详细信息，使其可以被 C/C++、Python、Lua (via FFI) 等多种语言轻松调用。所有 C 接口在失败时都会设置标准的 Win32 错误码，可通过 `GetLastError()` 获取。


2.0 功能特性
------------
*   进程查找与枚举:
    - 按 PID 或进程名打开进程并获取句柄。
    - 检查进程是否存在。
    - 查找所有同名进程的 PID 列表。

*   进程创建与执行:
    - `CreateProcess`: 创建新进程，并原子性地返回 PID 和进程句柄。
    - `LaunchProcess`: 以“发后不理”的方式启动新进程，只返回 PID。
    - `CreateProcessAsSystem`: 在当前活动桌面以 `SYSTEM` 权限创建进程。

*   进程终止:
    - 按 PID 强制终止指定进程。
    - 终止一个完整的进程树，包括所有子进程。

*   进程等待:
    - 同步等待，直到指定名称的进程出现。
    - 同步等待，直到指定进程结束。
    - 通过进程句柄高效等待进程结束。

*   信息获取:
    - 获取进程的详细信息，包括 PID、父 PID、会话 ID、内存使用、线程数、可执行文件路径以及完整的命令行参数。
    - 单独获取进程的父进程 PID 或命令行。

*   属性修改:
    - 设置进程的 CPU 优先级。

*   接口设计:
    - 纯 C 接口 (`extern "C"`)，确保了跨语言调用的兼容性。
    - 提供一个头文件级别的现代 C++ 封装 (`ProcUtils::Process` 类)，使用 RAII 自动管理进程句柄，并通过移动语义和 `std::optional` 提供类型安全。


3.0 如何使用
------------
你需要 `proc_utils.dll` (或 `proc_utils.lib` 用于静态链接) 和 `proc_utils.h` 这两个文件。

1.  将 `proc_utils.h` 包含到您的源代码中。
2.  链接 `proc_utils.lib`。
3.  确保 `proc_utils.dll` 在运行时可被找到 (如果使用动态链接)。

3.1 C 语言接口使用方法

    #include "proc_utils.h"
    #include <stdio.h>
    #include <windows.h>

    #pragma comment(lib, "proc_utils.lib")

    int main() {
        const wchar_t* process_name = L"notepad.exe";
        
        // 场景: 创建进程并等待其结束
        // ProcUtils_CreateProcess 返回一个包含句柄的结构体
        ProcUtils_ProcessResult result = ProcUtils_CreateProcess(process_name, NULL, SW_SHOW, NULL);
        
        if (result.pid > 0 && result.process_handle != NULL) {
            printf("CreateProcess 成功, PID: %u, Handle: %p\n", result.pid, result.process_handle);

            printf("等待 3 秒或直到进程关闭...\n");
            
            // 使用新的基于句柄的等待函数，这是最高效的方式
            ProcUtils_WaitForProcessExit(result.process_handle, 3000);
            
            printf("等待结束。\n");

            // *重要*: C 接口要求调用者必须手动关闭通过 CreateProcess 获取的句柄！
            CloseHandle(result.process_handle);
        } else {
            printf("创建进程失败，错误码: %lu\n", result.last_error_code);
        }
        
        return 0;
    }

3.2 C++ 封装使用方法 (推荐)

    #include "proc_utils.h"
    #include <iostream>
    #include <string>

    #pragma comment(lib, "proc_utils.lib")

    int main() {
        // 使用 C++ 封装，它通过 RAII 自动管理句柄的生命周期。
        // 使用 std::optional 进行安全的错误处理。
        if (auto notepad = ProcUtils::Process::exec(L"notepad.exe C:\\log.txt")) {
            // notepad 是一个 std::optional<ProcUtils::Process>
            std::wcout << L"成功启动 notepad.exe, PID: " << notepad->id() 
                       << L", Handle: " << notepad->handle() << std::endl;
            
            // 获取增强的进程信息
            if (auto info = notepad->get_info()) {
                std::wcout << L"  路径: " << info->exe_path << std::endl;
                std::wcout << L"  命令行: " << info->command_line << std::endl;
                std::wcout << L"  父进程ID: " << info->parent_pid << std::endl;
                std::wcout << L"  内存使用: " << info->memory_usage_bytes / 1024 << " KB" << std::endl;
            }

            notepad->wait_for_exit(3000); // 等待最多3秒
            
            // notepad 对象离开作用域时，其析构函数会自动调用 CloseHandle，无需手动管理。
        }
        else {
            std::wcerr << L"启动 notepad.exe 失败, 错误码: " << GetLastError() << std::endl;
        }
        
        std::wcout << L"notepad.exe 已关闭或其句柄已被自动释放。" << std::endl;
        
        return 0;
    }


4.0 从源码构建
----------------
你需要 CMake (3.10+) 和一个支持 C++17 的编译器 (例如 Visual Studio 2022)。

1.  克隆或下载仓库。
2.  打开命令行工具 (如 x64 Native Tools Command Prompt for VS)。
3.  进入项目根目录。
4.  执行以下命令：

    // 配置 (构建动态库 .dll, 这是默认选项)
    cmake -B build -G "Visual Studio 17 2022" -A x64

    // 配置 (构建静态库 .lib)
    cmake -B build -G "Visual Studio 17 2022" -A x64 -DBUILD_SHARED_LIBS=OFF

    // 编译
    cmake --build build --config Release

5.  构建产物位于 `build/Release` 目录下。


5.0 C 语言 API 参考
---------------------

5.1 结构体定义

*   struct ProcUtils_ProcessInfo
    描述: 存储进程的详细信息。
    字段:
    - DWORD pid: 进程 ID.
    - DWORD parent_pid: 父进程 ID.
    - DWORD session_id: 进程所属的会话 ID.
    - wchar_t exe_path[260]: 可执行文件的完整路径.
    - wchar_t command_line[2048]: 启动进程的完整命令行.
    - unsigned long long memory_usage_bytes: 进程工作集大小 (物理内存使用量).
    - DWORD thread_count: 进程拥有的线程数.

*   struct ProcUtils_ProcessResult
    描述: ProcUtils_CreateProcess 函数的返回值，包含 PID、句柄和错误码。
    *注意*: 调用者获得句柄后，有责任在不再需要时调用 `CloseHandle()` 来释放它。
    字段:
    - DWORD pid: 创建的进程 ID.
    - void* process_handle: 创建的进程句柄 (类型为 HANDLE).
    - DWORD last_error_code: 如果创建失败，这里会包含 GetLastError() 的值.

5.2 模块 1：进程查找与枚举

*   void* ProcUtils_OpenProcessByPid(DWORD pid, DWORD desired_access)
    描述: 通过进程 ID (PID) 打开一个已存在的进程对象。
    参数:
    - pid: 目标进程的 ID.
    - desired_access: 访问权限，例如 `PROCESS_ALL_ACCESS` 或 `PROCESS_QUERY_INFORMATION`。
    返回值: 成功则返回进程句柄，失败返回 `NULL`。

*   void* ProcUtils_OpenProcessByName(const wchar_t* process_name, DWORD desired_access)
    描述: 通过进程可执行文件名查找并打开第一个匹配的进程。
    参数:
    - process_name: 进程的可执行文件名，例如 L"notepad.exe"。
    - desired_access: 访问权限。
    返回值: 成功则返回进程句柄，失败返回 `NULL`。

*   int ProcUtils_FindAllProcesses(const wchar_t* process_name, DWORD* out_pids, int pids_array_size)
    描述: 查找所有与指定名称匹配的进程。此函数有两种工作模式：
    1.  如果 `out_pids` 为 `NULL`，它只返回找到的进程总数。
    2.  如果 `out_pids` 是一个有效的数组，它会将找到的 PID 填入该数组，最多填充 `pids_array_size` 个。
    参数:
    - process_name: 要查找的进程名称。
    - out_pids: 用于存储 PID 的数组，或为 `NULL` 以获取计数。
    - pids_array_size: `out_pids` 数组的大小。
    返回值: 如果 `out_pids` 为 `NULL`，返回找到的总数。如果提供了 `out_pids`，返回实际存入数组的 PID 数量。失败返回 -1。

*   DWORD ProcUtils_ProcessExists(const wchar_t* process_name_or_pid)
    描述: 检查一个进程是否存在。
    参数:
    - process_name_or_pid: 进程名 (L"notepad.exe") 或 PID 的字符串形式 (L"1234")。
    返回值: 如果进程存在，返回其 PID (大于 0)。如果不存在，返回 0。

5.3 模块 2：进程创建与执行

*   ProcUtils_ProcessResult ProcUtils_CreateProcess(const wchar_t* command, const wchar_t* working_dir, int show_mode, const wchar_t* desktop_name)
    描述: 创建一个新进程，并返回其 PID 和一个可用的句柄。
    参数:
    - command: 要执行的完整命令行。
    - working_dir: 新进程的工作目录，可为 `NULL`。
    - show_mode: 窗口显示模式，例如 `SW_SHOW` 或 `SW_HIDE`。
    - desktop_name: 进程运行的桌面名称，通常为 `NULL`。
    返回值: `ProcUtils_ProcessResult` 结构体。检查 `pid > 0` 和 `process_handle != NULL` 来判断是否成功。失败时，错误码在 `last_error_code` 中。

*   DWORD ProcUtils_LaunchProcess(const wchar_t* command, const wchar_t* working_dir, int show_mode, const wchar_t* desktop_name)
    描述: 以“发后不理”的方式启动一个新进程，只返回其 PID，不返回句柄。
    参数: 同上。
    返回值: 成功则返回新进程的 PID，失败返回 0。

*   ProcUtils_ProcessResult ProcUtils_CreateProcessAsSystem(const wchar_t* command, const wchar_t* working_dir, int show_mode)
    描述: 尝试在当前活动的控制台会话中以 `SYSTEM` 权限创建一个新进程。*此函数需要调用者拥有足够的权限* (通常是管理员权限)。
    参数:
    - command: 要执行的完整命令行。
    - working_dir: 工作目录。
    - show_mode: 窗口显示模式。
    返回值: `ProcUtils_ProcessResult` 结构体，用法同 `ProcUtils_CreateProcess`。

5.4 模块 3：进程信息获取

*   bool ProcUtils_ProcessGetInfo(DWORD pid, ProcUtils_ProcessInfo* out_info)
    描述: 获取指定 PID 进程的详细信息。
    参数:
    - pid: 目标进程的 ID.
    - out_info: 指向 `ProcUtils_ProcessInfo` 结构体的指针，用于接收信息。
    返回值: 成功返回 `true`，失败返回 `false`。

*   bool ProcUtils_ProcessGetCommandLine(DWORD pid, wchar_t* out_cmd, int cmd_size)
    描述: 单独获取指定 PID 进程的完整命令行。
    参数:
    - pid: 目标进程的 ID.
    - out_cmd: 用于存储命令行的宽字符缓冲区。
    - cmd_size: 缓冲区大小 (以字符计)。
    返回值: 成功返回 `true`，失败返回 `false`。

*   bool ProcUtils_ProcessGetPath(DWORD pid, wchar_t* out_path, int path_size)
    描述: 获取指定 PID 进程的可执行文件完整路径。
    参数:
    - pid: 目标进程的 ID.
    - out_path: 用于存储路径的宽字符缓冲区。
    - path_size: 缓冲区大小 (以字符计)。
    返回值: 成功返回 `true`，失败返回 `false`。

*   DWORD ProcUtils_ProcessGetParent(const wchar_t* process_name_or_pid)
    描述: 获取指定进程的父进程 ID。
    参数:
    - process_name_or_pid: 进程名或 PID 字符串。
    返回值: 成功返回父进程的 PID，失败返回 0。

5.5 模块 4：进程控制与交互

*   bool ProcUtils_ProcessClose(const wchar_t* process_name_or_pid, UINT exit_code)
    描述: 查找并终止一个进程。
    参数:
    - process_name_or_pid: 进程名或 PID 字符串。
    - exit_code: 进程的退出码。
    返回值: 成功返回 `true`，失败返回 `false`。

*   bool ProcUtils_TerminateProcessByPid(DWORD pid, UINT exit_code)
    描述: 通过 PID 直接终止一个进程。
    参数:
    - pid: 要终止的进程 ID。
    - exit_code: 进程的退出码。
    返回值: 成功返回 `true`，失败返回 `false`。

*   bool ProcUtils_ProcessCloseTree(const wchar_t* process_name_or_pid)
    描述: 查找一个进程并终止其整个进程树 (包括所有子进程)。
    参数:
    - process_name_or_pid: 根进程的名称或 PID 字符串。
    返回值: 成功返回 `true`，失败返回 `false`。

*   bool ProcUtils_TerminateProcessTreeByPid(DWORD pid)
    描述: 通过根进程的 PID 终止其整个进程树。
    参数:
    - pid: 根进程的 ID。
    返回值: 成功返回 `true`，失败返回 `false`。

*   bool ProcUtils_ProcessSetPriority(const wchar_t* process_name_or_pid, wchar_t priority)
    描述: 设置进程的 CPU 优先级。
    参数:
    - process_name_or_pid: 进程名或 PID 字符串。
    - priority: 优先级字符：'L'(低), 'B'(低于正常), 'N'(正常), 'A'(高于正常), 'H'(高), 'R'(实时)。不区分大小写。
    返回值: 成功返回 `true`，失败返回 `false`。

*   DWORD ProcUtils_ProcessWait(const wchar_t* process_name, int timeout_ms)
    描述: 同步等待，直到指定名称的进程出现。
    参数:
    - process_name: 要等待的进程名称。
    - timeout_ms: 超时时间 (毫秒)。-1 表示无限等待。
    返回值: 如果进程出现，返回其 PID。如果超时，返回 0。

*   bool ProcUtils_ProcessWaitClose(const wchar_t* process_name_or_pid, int timeout_ms)
    描述: 同步等待，直到指定的进程关闭。
    参数:
    - process_name_or_pid: 进程名或 PID 字符串。
    - timeout_ms: 超时时间 (毫秒)。-1 表示无限等待。
    返回值: 如果进程在超时前关闭，返回 `true`。如果超时，返回 `false`。

*   bool ProcUtils_WaitForProcessExit(void* process_handle, int timeout_ms)
    描述: 通过进程句柄等待一个进程结束。这是最高效的等待方式。
    参数:
    - process_handle: 一个有效的进程句柄 (例如从 `ProcUtils_CreateProcess` 获取)。
    - timeout_ms: 超时时间 (毫秒)。-1 表示无限等待 (`INFINITE`)。
    返回值: 如果进程在超时前结束，返回 `true`。如果超时，返回 `false`。


6.0 C++ 封装 (ProcUtils::Process) API 参考
--------------------------------------------

6.1 设计理念
*   RAII (资源获取即初始化): `Process` 对象在构造时获取进程句柄，在析构时自动调用 `CloseHandle` 释放句柄，防止资源泄漏。
*   移动语义: `Process` 对象是移动唯一的 (`move-only`)，禁止拷贝，确保了句柄资源的所有权清晰。
*   现代 C++ 特性: 使用 `std::optional` 和 `std::vector` 返回结果，避免了空指针和手动管理内存，使接口更安全、更易用。

6.2 静态工厂方法 (推荐的创建方式)

*   static std::optional<Process> open_by_pid(DWORD pid, DWORD access = PROCESS_ALL_ACCESS)
    通过 PID 打开进程，返回一个 `Process` 对象。

*   static std::optional<Process> open_by_name(const std::wstring& name, DWORD access = PROCESS_ALL_ACCESS)
    通过名称打开进程，返回一个 `Process` 对象。

*   static std::vector<DWORD> find_all_by_name(const std::wstring& name)
    查找所有同名进程，返回一个包含所有 PID 的 `std::vector`。

*   static std::optional<Process> exec(const std::wstring& command, ...)
    创建新进程，并返回一个管理该进程的 `Process` 对象。失败则返回 `std::nullopt`。

*   static std::optional<Process> exec_as_system(const std::wstring& command, ...)
    以 `SYSTEM` 权限创建新进程，并返回一个 `Process` 对象。

*   static DWORD launch(const std::wstring& command, ...)
    以“发后不理”模式启动进程，只返回 PID。

6.3 成员方法

*   bool is_valid() const
    检查内部句柄是否有效。

*   DWORD id() const
    返回进程的 PID。

*   HANDLE handle() const
    返回进程的句柄。

*   bool terminate(UINT exit_code = 0)
    终止此进程。

*   static bool terminate_by_pid(DWORD pid, UINT exit_code = 0)
    静态方法，通过 PID 终止进程。

*   bool terminate_tree()
    终止此进程及其所有子进程。

*   bool wait_for_exit(int timeout_ms = -1)
    等待此进程结束。

*   std::optional<ProcUtils_ProcessInfo> get_info() const
    获取此进程的详细信息。

*   std::optional<std::wstring> get_command_line() const
    获取此进程的命令行。

*   std::wstring get_path() const
    获取此进程的可执行文件路径。


7.0 许可证
------------
本项目采用 MIT 许可证。