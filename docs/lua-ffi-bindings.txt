Lua-FFI-Bindings å®Œæ•´ API è§„æ ¼è¯´æ˜ä¹¦
ç‰ˆæœ¬ï¼šdev-1
é€‚ç”¨ç¯å¢ƒï¼šLuaJIT 2.0 / 2.1 (Windows/Linux/macOS)
æ–‡æ¡£ç”Ÿæˆæ—¶é—´ï¼š2025-11-22

================================================================================
1. å¿«é€Ÿä¸Šæ‰‹ (Quick Start)
================================================================================

æœ¬åº“æ˜¯ C è¯­è¨€å¤´æ–‡ä»¶çš„æ›¿ä»£å“ã€‚ä½ ä¸éœ€è¦ `ffi.cdef`ï¼Œåªéœ€ `require` å¯¹åº”çš„æ¨¡å—è·¯å¾„ã€‚

```lua
local ffi = require 'ffi'
-- 1. åŠ è½½å®šä¹‰ (ç›¸å½“äº #include <stdio.h>)
require 'ffi.req' 'c.stdio'
-- 2. åŠ è½½ Windows Kernel32 å®šä¹‰ (ç›¸å½“äº #include <windows.h>)
require 'ffi.req' 'Windows.sdk.kernel32'

-- 3. ä½¿ç”¨ (ç›´æ¥è°ƒç”¨ ffi.C æˆ–åŠ è½½çš„åº“)
local kernel32 = ffi.load('kernel32')
local handle = kernel32.GetCurrentProcessId()
```

**æ ¸å¿ƒæœºåˆ¶**:
- `require 'ffi.req' 'æ¨¡å—å'`ï¼šæ™ºèƒ½åŠ è½½å™¨ã€‚ä¼šè‡ªåŠ¨æ ¹æ® OS (Windows/Linux) å’Œæ¶æ„ (x64/x86) æŸ¥æ‰¾æœ€åŒ¹é…çš„å®šä¹‰æ–‡ä»¶ã€‚
- `require 'ffi.load' 'åº“å'`ï¼šè·¨å¹³å°åŠ¨æ€åº“åŠ è½½å™¨ã€‚ä¾‹å¦‚ `'socket'` ä¼šè‡ªåŠ¨æ˜ å°„ä¸º `ws2_32.dll` (Win) æˆ– `libc.so` (Linux)ã€‚

================================================================================
2. Windows SDK æ¨¡å—è¯¦è§£
================================================================================

ä»¥ä¸‹æ¨¡å—ä½äº `Windows.sdk.` å‘½åç©ºé—´ã€‚
**é‡è¦æç¤º**ï¼šæœ¬åº“å¼ºåˆ¶ä½¿ç”¨ Unicodeã€‚å‡¡æ˜¯æ¶‰åŠå­—ç¬¦ä¸²çš„ APIï¼Œ**å¿…é¡»**ä¼ å…¥ `ffi.new("wchar_t[?]", ...)` æˆ–ä½¿ç”¨ `lua-ext` / `proc_utils` æä¾›çš„è½¬æ¢å·¥å…·ã€‚

--------------------------------------------------------------------------------
2.1 åŸºç¡€ç±»å‹å®šä¹‰ (Windows.sdk.minwindef)
--------------------------------------------------------------------------------
*è¯¥æ¨¡å—è¢«å…¶ä»– SDK æ¨¡å—è‡ªåŠ¨åŠ è½½ï¼Œæ— éœ€æ‰‹åŠ¨ requireã€‚*

**ç±»å‹æ˜ å°„**:
- `DWORD` -> `unsigned long`
- `WORD` -> `unsigned short`
- `BYTE` -> `unsigned char`
- `BOOL` -> `int`
- `HANDLE`, `HINSTANCE`, `HMODULE`, `HWND`, `HLOCAL` -> `void*`
- `LPCWSTR`, `LPWSTR` -> `wchar_t*`
- `LPSTR`, `LPCSTR` -> `char*`
- `PVOID`, `LPVOID` -> `void*`
- `ULONG` -> `unsigned long`
- `LONG` -> `long`
- `ULONGLONG` -> `unsigned long long`

--------------------------------------------------------------------------------
2.2 æ ¸å¿ƒå†…æ ¸ (Windows.sdk.kernel32)
--------------------------------------------------------------------------------
åŠ è½½æ–¹å¼ï¼šlocal k32 = ffi.load("kernel32"); require 'ffi.req' 'Windows.sdk.kernel32'

[å¸¸é‡å®šä¹‰]

è¿›ç¨‹æƒé™æ©ç ï¼š
PROCESS_TERMINATE (0x0001)
PROCESS_CREATE_THREAD (0x0002)
PROCESS_SET_SESSIONID (0x0004)
PROCESS_VM_OPERATION (0x0008)
PROCESS_VM_READ (0x0010)
PROCESS_VM_WRITE (0x0020)
PROCESS_DUP_HANDLE (0x0040)
PROCESS_CREATE_PROCESS (0x0080)
PROCESS_SET_QUOTA (0x0100)
PROCESS_SET_INFORMATION (0x0200)
PROCESS_QUERY_INFORMATION (0x0400)
PROCESS_QUERY_LIMITED_INFORMATION (0x1000)
PROCESS_ALL_ACCESS (0x1F0FFF)

åŒæ­¥ä¸ç­‰å¾…ï¼š
SYNCHRONIZE (0x00100000)
INFINITE (0xFFFFFFFF)
WAIT_OBJECT_0 (0)
WAIT_TIMEOUT (258)
WAIT_FAILED (0xFFFFFFFF)

å¿«ç…§ä¸å¯åŠ¨ï¼š
TH32CS_SNAPPROCESS (0x00000002)
STARTF_USESHOWWINDOW (0x00000001)

é”™è¯¯ä»£ç ï¼š
ERROR_ACCESS_DENIED (5)
ERROR_INVALID_PARAMETER (87)
ERROR_NOT_FOUND (1168)

ä¼˜å…ˆçº§ç±»ï¼š
IDLE_PRIORITY_CLASS (0x40)
BELOW_NORMAL_PRIORITY_CLASS (0x4000)
NORMAL_PRIORITY_CLASS (0x20)
ABOVE_NORMAL_PRIORITY_CLASS (0x8000)
HIGH_PRIORITY_CLASS (0x80)
REALTIME_PRIORITY_CLASS (0x100)

æ ¼å¼åŒ–æ¶ˆæ¯ä¸ç¼–ç ï¼š
FORMAT_MESSAGE_ALLOCATE_BUFFER (0x100)
FORMAT_MESSAGE_FROM_SYSTEM (0x1000)
FORMAT_MESSAGE_IGNORE_INSERTS (0x200)
CP_UTF8 (65001)

æ–‡ä»¶ä¸å¤„ç½® (æ–°å¢)ï¼š
DELETE (0x00010000)
FILE_SHARE_READ (1)
FILE_SHARE_WRITE (2)
FILE_SHARE_DELETE (4)
OPEN_EXISTING (3)
FILE_FLAG_BACKUP_SEMANTICS (0x02000000)
FileDispositionInfoEx (21) - ç”¨äº SetFileInformationByHandle
FILE_DISPOSITION_DELETE (1)
FILE_DISPOSITION_POSIX_SEMANTICS (2)

[ç»“æ„ä½“å®šä¹‰]

STARTUPINFOW: åŒ…å« cb, lpDesktop, lpTitle, dwFlags, wShowWindow, hStdInput/Output/Error ç­‰ã€‚
PROCESS_INFORMATION: åŒ…å« hProcess, hThread, dwProcessId, dwThreadIdã€‚
PROCESSENTRY32W: ç”¨äºè¿›ç¨‹å¿«ç…§éå† (szExeFile ä¸º WCHAR[260])ã€‚
FILE_DISPOSITION_INFO_EX: åŒ…å« Flags (DWORD)ï¼Œç”¨äºæ‰©å±•æ–‡ä»¶åˆ é™¤æ“ä½œã€‚

[å‡½æ•°åŸå‹ API]

1. å¥æŸ„æ“ä½œ
BOOL CloseHandle(HANDLE hObject)

2. å·¥å…·å¸®åŠ© (Toolhelp32)
HANDLE CreateToolhelp32Snapshot(DWORD dwFlags, DWORD th32ProcessID)
BOOL Process32FirstW(HANDLE hSnapshot, PROCESSENTRY32W* lppe)
BOOL Process32NextW(HANDLE hSnapshot, PROCESSENTRY32W* lppe)

3. è¿›ç¨‹ä¸çº¿ç¨‹ç®¡ç†
BOOL CreateProcessW(LPCWSTR, LPWSTR, void*, void*, BOOL, DWORD, void*, LPCWSTR, STARTUPINFOW*, PROCESS_INFORMATION*)
HANDLE OpenProcess(DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwProcessId)
BOOL TerminateProcess(HANDLE hProcess, unsigned int uExitCode)
DWORD WaitForSingleObject(HANDLE hHandle, DWORD dwMilliseconds)
BOOL SetPriorityClass(HANDLE hProcess, DWORD dwPriorityClass)
BOOL ProcessIdToSessionId(DWORD dwProcessId, DWORD* pSessionId)
BOOL ReadProcessMemory(HANDLE hProcess, const void* lpBaseAddress, void* lpBuffer, size_t nSize, size_t* lpNumberOfBytesRead)
void Sleep(DWORD dwMilliseconds)
DWORD GetTickCount(void)
ULONGLONG GetTickCount64(void)
DWORD GetCurrentProcessId(void)
DWORD GetProcessId(HANDLE hProcess)
DWORD GetModuleFileNameW(HMODULE hModule, LPWSTR lpFilename, DWORD nSize)
LPWSTR GetCommandLineW(void)
BOOL QueryFullProcessImageNameW(HANDLE hProcess, DWORD dwFlags, LPWSTR lpExeName, DWORD* lpdwSize)
DWORD WTSGetActiveConsoleSessionId(void)

4. ç¯å¢ƒå˜é‡ (æ–°å¢)
BOOL SetEnvironmentVariableW(LPCWSTR lpName, LPCWSTR lpValue)
DWORD GetEnvironmentVariableW(LPCWSTR lpName, LPWSTR lpBuffer, DWORD nSize)

5. äº‹ä»¶åŒæ­¥ (æ–°å¢)
HANDLE CreateEventW(void* lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCWSTR lpName)
HANDLE OpenEventW(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName)
BOOL SetEvent(HANDLE hEvent)
BOOL ResetEvent(HANDLE hEvent)

6. æ–‡ä»¶ç³»ç»Ÿæ“ä½œ (å¤§å¹…å¢å¼º)
HANDLE CreateFileW(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, void* lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile)
BOOL CopyFileW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, BOOL bFailIfExists)
BOOL CreateHardLinkW(LPCWSTR lpFileName, LPCWSTR lpExistingFileName, void* lpSecurityAttributes)
BOOLEAN CreateSymbolicLinkW(LPCWSTR lpSymlinkFileName, LPCWSTR lpTargetFileName, DWORD dwFlags)
DWORD GetShortPathNameW(LPCWSTR lpszLongPath, LPWSTR lpszShortPath, DWORD cchBuffer)
DWORD GetTempPathW(DWORD nBufferLength, LPWSTR lpBuffer)
UINT GetTempFileNameW(LPCWSTR lpPathName, LPCWSTR lpPrefixString, UINT uUnique, LPWSTR lpTempFileName)
BOOL SetFileInformationByHandle(HANDLE hFile, int FileInformationClass, void* lpFileInformation, DWORD dwBufferSize)

7. å†…å­˜ç®¡ç†
HLOCAL LocalFree(HLOCAL hMem)

8. å­—ç¬¦ä¸²ç¼–ç 
int WideCharToMultiByte(unsigned int CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr, int cbMultiByte, LPCSTR lpDefaultChar, int* lpUsedDefaultChar)
int MultiByteToWideChar(unsigned int CodePage, DWORD dwFlags, LPCSTR lpMultiByteStr, int cbMultiByte, LPTSTR lpWideCharStr, int cchWideChar)

9. é”™è¯¯å¤„ç†
DWORD GetLastError(void)
void SetLastError(DWORD dwErrCode)
DWORD FormatMessageW(DWORD dwFlags, const void* lpSource, DWORD dwMessageId, DWORD dwLanguageId, LPWSTR lpBuffer, DWORD nSize, void* Arguments)

--------------------------------------------------------------------------------
2.3 è¿›ç¨‹çŠ¶æ€ (Windows.sdk.psapi)
--------------------------------------------------------------------------------
**åŠ è½½æ–¹å¼**: `local psapi = ffi.load("psapi"); require 'ffi.req' 'Windows.sdk.psapi'`

**ç»“æ„ä½“**:
- `PROCESS_MEMORY_COUNTERS_EX`: åŒ…å« `WorkingSetSize`, `PrivateUsage` ç­‰ã€‚

**å‡½æ•°åŸå‹**:
- `DWORD GetModuleFileNameExW(HANDLE hProcess, HMODULE hModule, LPWSTR filename, DWORD size)`
- `BOOL GetProcessMemoryInfo(HANDLE hProcess, void* ppsmemCounters, DWORD cb)`

--------------------------------------------------------------------------------
2.4 é«˜çº§å®‰å…¨ (Windows.sdk.advapi32)
--------------------------------------------------------------------------------
**åŠ è½½æ–¹å¼**: `local adv = ffi.load("advapi32"); require 'ffi.req' 'Windows.sdk.advapi32'`

**å¸¸é‡**:
- `MAXIMUM_ALLOWED`
- `CREATE_UNICODE_ENVIRONMENT` (0x00000400)

**æšä¸¾**:
- `SECURITY_IMPERSONATION_LEVEL`: `SecurityIdentification` (1)
- `TOKEN_TYPE`: `TokenPrimary` (1)

**å‡½æ•°åŸå‹**:
- `BOOL CreateProcessAsUserW(HANDLE hToken, LPCWSTR app, LPWSTR cmd, void* pAttr, void* tAttr, BOOL inherit, DWORD flags, void* env, LPCWSTR dir, void* si, void* pi)`
- `BOOL DuplicateTokenEx(HANDLE hExisting, DWORD access, void* attr, int level, int type, HANDLE* phNew)`

--------------------------------------------------------------------------------
2.5 ç»ˆç«¯æœåŠ¡ (Windows.sdk.wtsapi32)
--------------------------------------------------------------------------------
**åŠ è½½æ–¹å¼**: `local wts = ffi.load("wtsapi32"); require 'ffi.req' 'Windows.sdk.wtsapi32'`

**å‡½æ•°åŸå‹**:
- `BOOL WTSQueryUserToken(ULONG sessionId, HANDLE* phToken)`

--------------------------------------------------------------------------------
2.6 ç”¨æˆ·ç¯å¢ƒ (Windows.sdk.userenv)
--------------------------------------------------------------------------------
**åŠ è½½æ–¹å¼**: `local uenv = ffi.load("userenv"); require 'ffi.req' 'Windows.sdk.userenv'`

**å‡½æ•°åŸå‹**:
- `BOOL CreateEnvironmentBlock(void** lpEnv, HANDLE hToken, BOOL inherit)`
- `BOOL DestroyEnvironmentBlock(void* lpEnv)`

--------------------------------------------------------------------------------
2.7 NT åº•å±‚ API (Windows.sdk.ntdll)
--------------------------------------------------------------------------------
**åŠ è½½æ–¹å¼**: `local ntdll = ffi.load("ntdll"); require 'ffi.req' 'Windows.sdk.ntdll'`

**ç»“æ„ä½“**:
- `UNICODE_STRING`: `{ Length, MaximumLength, Buffer }`
- `RTL_USER_PROCESS_PARAMETERS`: åŒ…å« `ImagePathName`, `CommandLine` (å‡ä¸º UNICODE_STRING)ã€‚
- `PEB`: åŒ…å« `ProcessParameters` æŒ‡é’ˆã€‚
- `PROCESS_BASIC_INFORMATION`: åŒ…å« `ExitStatus`, `PebBaseAddress`ã€‚

**å‡½æ•°åŸå‹**:
- `long __stdcall NtQueryInformationProcess(HANDLE hProcess, int infoClass, PVOID info, ULONG len, ULONG* retLen)`
  - `infoClass`: 0 (ProcessBasicInformation)

--------------------------------------------------------------------------------
2.8 å¤–å£³ (Windows.sdk.shell32)
--------------------------------------------------------------------------------
**åŠ è½½æ–¹å¼**: `local shell = require 'ffi.req' 'Windows.sdk.shell32'` (æ³¨æ„ï¼šæ­¤æ¨¡å—è¿”å›å°è£…åçš„å¯¹è±¡)

**åŸç”Ÿå‡½æ•° (ffi.C)**:
- `LPWSTR* CommandLineToArgvW(LPCWSTR cmdLine, int* numArgs)`
- `LPCWSTR GetCommandLineW(void)`

**Lua å°è£…è¾…åŠ©å‡½æ•°**:
- `shell.commandline_to_argv(cmd_line_string)`: è¾“å…¥ UTF-8 å­—ç¬¦ä¸²ï¼Œè¿”å›å‚æ•° tableã€‚
- `shell.get_arguments()`: è·å–å½“å‰è¿›ç¨‹çš„å‚æ•° table (UTF-8)ã€‚

================================================================================
3. C æ ‡å‡†åº“ (CRT) æ¨¡å—è¯¦è§£
================================================================================

ä»¥ä¸‹æ¨¡å—ä½äº `c.` å‘½åç©ºé—´ï¼Œå¤§å¤šæ•°å®šä¹‰åœ¨ `ffi.C` ä¸­ã€‚
**Windows ç‰¹æ€§**ï¼šæœ¬åº“è‡ªåŠ¨å°†æ ‡å‡†å‡½æ•°æ˜ å°„ä¸º Microsoft UCRT çš„å®½å­—ç¬¦ç‰ˆæœ¬ã€‚

--------------------------------------------------------------------------------
3.1 æ–‡ä»¶æ“ä½œ (c.stdio / c.io)
--------------------------------------------------------------------------------
**req**: `c.stdio` (æ ‡å‡†), `c.io` (Windowsåº•å±‚)

**ç»“æ„ä½“**: `FILE`, `struct _finddata32_t` / `_finddata64i32_t` (Windows)

**Windows ç‰¹æœ‰å‡½æ•°**:
- `int _fileno(FILE* stream)`
- `int _setmode(int fd, int mode)`: æ¨¡å¼ 0x4000 (Text), 0x8000 (Binary)ã€‚
- `int _locking(int fd, int mode, long nbytes)`
- `FILE* _wfopen(const wchar_t* filename, const wchar_t* mode)`
- `FILE* _wpopen(const wchar_t* cmd, const wchar_t* mode)`
- `int _pclose(FILE* stream)`
- `intptr_t _wfindfirst64i32(const wchar_t* name, struct _wfinddata64i32_t* fileinfo)`
- `int _wfindnext64i32(intptr_t handle, struct _wfinddata64i32_t* fileinfo)`
- `int _findclose(intptr_t handle)`

**æ ‡å‡†å‡½æ•° (å…¨å¹³å°)**:
- `fopen`, `fclose`, `fread`, `fwrite`, `fflush`, `fseek`, `ftell`, `feof`
- `printf`, `sprintf`, `snprintf` (Windowsä¸‹ä¸º `_snprintf`)

--------------------------------------------------------------------------------
3.2 ç›®å½•æ“ä½œ (c.direct / c.unistd)
--------------------------------------------------------------------------------
**req**: `c.direct` (Windows), `c.unistd` (Linux/Mac)

**Windows ç‰¹æœ‰å‡½æ•°**:
- `int _wchdir(const wchar_t* path)`
- `wchar_t* _wgetcwd(wchar_t* buffer, int maxlen)`
- `int _wmkdir(const wchar_t* path)`
- `int _wrmdir(const wchar_t* path)`

--------------------------------------------------------------------------------
3.3 æ–‡ä»¶çŠ¶æ€ (c.sys.stat)
--------------------------------------------------------------------------------
**req**: `c.sys.stat`

**ç»“æ„ä½“**: `struct stat` (åœ¨ Windows ä¸‹è‡ªåŠ¨ typedef ä¸º `struct _stat64`)

**å‡½æ•°**:
- `int stat(const char* path, struct stat* buf)`
- `int _wstat64(const wchar_t* path, struct _stat64* buf)` (Windows)

--------------------------------------------------------------------------------
3.4 ç¯å¢ƒä¸è½¬æ¢ (c.stdlib)
--------------------------------------------------------------------------------
**req**: `c.stdlib`

**å‡½æ•°**:
- `void* malloc(size_t size)`
- `void free(void* ptr)`
- `int system(const char* cmd)` / `int _wsystem(const wchar_t* cmd)`
- `char* getenv(const char* var)` / `wchar_t* _wgetenv(const wchar_t* var)`
- `int _wputenv_s(const wchar_t* var, const wchar_t* val)`

--------------------------------------------------------------------------------
3.5 æ—¶é—´ (c.time)
--------------------------------------------------------------------------------
**req**: `c.time`

**ç»“æ„ä½“**: `struct tm`, `struct timespec`

**å‡½æ•°**:
- `time_t time(time_t* timer)`
- `struct tm* gmtime(const time_t* timer)`
- `wchar_t* _wctime(const time_t* timer)` (Windows)

================================================================================
4. å®ç”¨å·¥å…·æ¨¡å—
================================================================================

4.1 é”™è¯¯å¤„ç† (c.errno)
--------------------------------------------------------------------------------
**req**: `c.errno` (è¿”å›ä¸€ä¸ª table)

**API**:
- `errno.errno()`: è·å–å½“å‰ `errno` å€¼ (number)ã€‚
- `errno.str()`: è·å–å½“å‰ `errno` å¯¹åº”çš„é”™è¯¯æè¿°å­—ç¬¦ä¸² (string)ã€‚
- `errno.EACCES`, `errno.ENOENT` ç­‰å¸¸é‡å®šä¹‰ã€‚

================================================================================
5. å¼€å‘ç¤ºä¾‹ï¼šä¸çœ‹æºç å†™ä»£ç 
================================================================================

**ä»»åŠ¡**ï¼šåœ¨ Windows ä¸‹åˆ›å»ºä¸€ä¸ªç›®å½• "C:\Test ğŸš€"ï¼Œå¹¶æ£€æŸ¥æ˜¯å¦åˆ›å»ºæˆåŠŸã€‚

**æŸ¥é˜…æ–‡æ¡£**ï¼š
1. ç›®å½•æ“ä½œåœ¨ `3.2 c.direct` -> `_wmkdir`ã€‚
2. å®½å­—ç¬¦è½¬æ¢éœ€ `kernel32` -> `MultiByteToWideChar`ã€‚
3. é”™è¯¯æ£€æŸ¥åœ¨ `c.errno`ã€‚

**ä»£ç å®ç°**ï¼š
```lua
local ffi = require 'ffi'
local C = ffi.C

-- 1. åŠ è½½å®šä¹‰
require 'ffi.req' 'c.direct'           -- å¼•å…¥ _wmkdir
require 'ffi.req' 'Windows.sdk.kernel32' -- å¼•å…¥ MultiByteToWideChar
local errno = require 'ffi.req' 'c.errno'

-- 2. è¾…åŠ©ï¼šUTF-8 è½¬ WCHAR (æ ¹æ® 2.2 èŠ‚ API)
local function to_w(str)
    local CP_UTF8 = 65001
    local len = C.MultiByteToWideChar(CP_UTF8, 0, str, -1, nil, 0)
    local buf = ffi.new("wchar_t[?]", len)
    C.MultiByteToWideChar(CP_UTF8, 0, str, -1, buf, len)
    return buf
end

-- 3. è°ƒç”¨
local path = to_w("C:\\Test ğŸš€")
if C._wmkdir(path) == 0 then
    print("Success")
else
    print("Failed: " .. errno.str())
end
```