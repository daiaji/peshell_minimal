# .github/workflows/ci.yml

name: CI Build and Test

on:
  push:
    branches: ["main", "master"]
  workflow_dispatch:

jobs:
  build-and-test:
    runs-on: windows-latest

    steps:
      - name: Checkout repository with submodules
        uses: actions/checkout@v4
        with:
          submodules: "recursive"

      - name: Setup MSVC environment
        uses: ilammy/msvc-dev-cmd@v1

      - name: Get LuaJIT submodule commit hash
        id: luajit-hash
        run: |
          # [修改] 路径已更新为 vendor/luajit
          $submodule_hash = (git submodule status vendor/luajit).Trim().Split(' ')[0]
          echo "hash=$submodule_hash" >> $env:GITHUB_OUTPUT
        shell: pwsh

      - name: Cache MSVC-built LuaJIT
        id: cache-luajit
        uses: actions/cache@v4
        with:
          path: .lua
          key: msvc-luajit-v3-${{ runner.os }}-${{ steps.luajit-hash.outputs.hash }}

      - name: Configure CMake for Release Build
        run: cmake -S . -B build -G "Ninja" -DCMAKE_BUILD_TYPE=Release

      - name: Build and install LuaJIT if not cached
        if: steps.cache-luajit.outputs.cache-hit != 'true'
        run: cmake --build build --config Release --target install_luajit

      - name: Add MSVC-built Lua to PATH
        run: echo "${{ github.workspace }}\.lua\bin" | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append
        shell: pwsh
      
      - name: Setup LuaRocks
        uses: luarocks/gh-actions-luarocks@v6

      - name: Build and Assemble Self-Contained Package
        id: assemble
        run: |
          # 1. 创建最终的包目录结构
          $package_dir = New-Item -ItemType Directory -Path "${{ github.workspace }}/package" -Force
          $bin_dir      = New-Item -ItemType Directory -Path "$package_dir/bin"
          $lua_dir      = New-Item -ItemType Directory -Path "$package_dir/share/lua/5.1" -Force
          
          # [[ 新增 ]] 创建专门存放纯 Lua 第三方库的目录
          $lib_dir      = New-Item -ItemType Directory -Path "$lua_dir/lib" -Force

          # 2. 编译我们自己的 C++ 代码 (使用 Release 配置)
          # 注意：CMakeLists.txt 已修改，不再编译 proc_utils C++ 库
          cmake --build build --config Release
          
          # 3. 将我们自己的产物复制到最终目录
          Write-Host "Copying project artifacts..."
          Copy-Item -Path "build/bin/*" -Destination $bin_dir

          # 4. 将我们自己的 Lua 脚本复制到最终目录
          Copy-Item -Path "scripts/*" -Destination $lua_dir -Recurse
          
          # [[ 新增 ]] 复制 proc_utils_ffi.lua 到 lib 目录
          # 这是这一步的核心变更，实现零编译依赖
          Write-Host "Installing proc_utils_ffi.lua to lib directory..."
          Copy-Item -Path "vendor/proc_utils/proc_utils_ffi.lua" -Destination "$lib_dir"

          Copy-Item -Path "start_peshell_main.bat" -Destination $package_dir

          # 5. 使用 LuaRocks 将 *依赖项* 安装到最终目录中
          Write-Host "Installing dependencies directly into the package..."
          luarocks install --tree=$package_dir peshell-minimal-dev-1.rockspec --only-deps
          
          # 6. 将所有依赖的 .dll 文件（如 lfs.dll）统一移动到 bin 目录
          Write-Host "Consolidating all DLLs into the bin directory..."
          if (Test-Path "$package_dir/lib") {
              Get-ChildItem -Path "$package_dir/lib" -Filter "*.dll" -Recurse | Move-Item -Destination $bin_dir -Force
          }
          
          # 7. 清理打包过程中的中间产物
          Write-Host "Cleaning up the package..."
          Write-Host "  -> Removing debug and intermediate files from bin..."
          Remove-Item -Path "$bin_dir/*.pdb", "$bin_dir/*.ilk" -ErrorAction SilentlyContinue
          Write-Host "  -> Removing temporary luarocks lib directory..."
          Remove-Item -Path "$package_dir/lib" -Recurse -Force

          echo "package_path=$package_dir" >> $env:GITHUB_OUTPUT
        shell: pwsh
        
      - name: Copy VC++ Redistributable DLLs
        run: |
          $vctools_redist_dir = $env:VCToolsRedistDir
          $package_bin_dir = "${{ steps.assemble.outputs.package_path }}/bin"
          Write-Host "Copying VC++ Redistributable DLLs from: $vctools_redist_dir"
          Copy-Item -Path "$vctools_redist_dir/x64/Microsoft.VC14*.CRT/*" -Destination $package_bin_dir -Recurse -Force
          Write-Host "Successfully copied VC++ runtime DLLs."
        shell: pwsh

      - name: Print final package structure
        run: |
          cd ${{ steps.assemble.outputs.package_path }}
          tree /F .
        shell: cmd

      - name: Clean up logs before test run
        run: |
          $log_dir = "${{ steps.assemble.outputs.package_path }}/logs"
          if (Test-Path $log_dir) {
            Write-Host "Found and removing existing logs directory before tests: $log_dir"
            Remove-Item -Path $log_dir -Recurse -Force
          }
        shell: pwsh

      - name: Run Lua Unit & Integration Tests
        working-directory: ${{ steps.assemble.outputs.package_path }}
        run: |
          # 工作目录已设置为 package 目录, 可以直接执行
          .\bin\peshell.exe run .\share\lua\5.1\test_suite.lua
        shell: pwsh

      - name: Clean up logs created by tests
        if: always()
        run: |
          Write-Host "Removing logs directory generated during test run to ensure a clean artifact..."
          Remove-Item -Path "${{ steps.assemble.outputs.package_path }}/logs" -Recurse -Force -ErrorAction SilentlyContinue
        shell: pwsh

      - name: Upload Build Artifact
        uses: actions/upload-artifact@v4
        with:
          name: peshell-build-artifact
          path: ${{ steps.assemble.outputs.package_path }}/
          retention-days: 7